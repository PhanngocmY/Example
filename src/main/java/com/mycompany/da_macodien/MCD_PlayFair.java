package com.mycompany.da_macodien;

import javax.swing.*;

public class MCD_PlayFair extends javax.swing.JFrame {

    private static final java.util.logging.Logger logger = java.util.logging.Logger.getLogger(MCD_PlayFair.class.getName());

    /**
     * Creates new form MCD_PlayFair
     */
    public MCD_PlayFair() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jButton3 = new javax.swing.JButton();
        jButton4 = new javax.swing.JButton();
        Plaintext = new javax.swing.JTextField();
        lbl_plaintext = new javax.swing.JLabel();
        Encrypt_Btn = new javax.swing.JButton();
        Decrypt_Btn = new javax.swing.JButton();
        lbl_ciphertext = new javax.swing.JLabel();
        Ciphertext = new javax.swing.JTextField();
        Exit_Btn = new javax.swing.JButton();
        lbl_key = new javax.swing.JLabel();
        Key = new javax.swing.JTextField();
        Tittle = new javax.swing.JLabel();
        Reset_Btn = new javax.swing.JButton();

        jButton3.setText("jButton1");

        jButton4.setText("jButton1");

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        Plaintext.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                PlaintextActionPerformed(evt);
            }
        });

        lbl_plaintext.setFont(new java.awt.Font("Segoe UI", 1, 12)); // NOI18N
        lbl_plaintext.setText("Plaintext");

        Encrypt_Btn.setText("Encrypt");
        Encrypt_Btn.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                Encrypt_BtnActionPerformed(evt);
            }
        });

        Decrypt_Btn.setText("Decrypt");
        Decrypt_Btn.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                Decrypt_BtnActionPerformed(evt);
            }
        });

        lbl_ciphertext.setFont(new java.awt.Font("Segoe UI", 1, 12)); // NOI18N
        lbl_ciphertext.setText("Ciphertext");

        Ciphertext.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                CiphertextActionPerformed(evt);
            }
        });

        Exit_Btn.setText("Exit");
        Exit_Btn.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                Exit_BtnActionPerformed(evt);
            }
        });

        lbl_key.setFont(new java.awt.Font("Segoe UI", 1, 12)); // NOI18N
        lbl_key.setText("Key");

        Key.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                KeyActionPerformed(evt);
            }
        });

        Tittle.setFont(new java.awt.Font("Segoe UI", 1, 24)); // NOI18N
        Tittle.setText("PLAYFAIR");

        Reset_Btn.setText("Reset");
        Reset_Btn.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                Reset_BtnActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(19, 19, 19)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(lbl_ciphertext)
                    .addComponent(lbl_plaintext)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(6, 6, 6)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(Ciphertext, javax.swing.GroupLayout.PREFERRED_SIZE, 194, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(Plaintext, javax.swing.GroupLayout.PREFERRED_SIZE, 194, javax.swing.GroupLayout.PREFERRED_SIZE))))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 30, Short.MAX_VALUE)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                            .addComponent(Decrypt_Btn, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(Encrypt_Btn, javax.swing.GroupLayout.Alignment.LEADING))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(Exit_Btn, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(Reset_Btn))
                        .addGap(18, 18, 18))
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(Key, javax.swing.GroupLayout.PREFERRED_SIZE, 148, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(lbl_key))
                        .addContainerGap())))
            .addGroup(layout.createSequentialGroup()
                .addGap(138, 138, 138)
                .addComponent(Tittle)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(Tittle)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(0, 0, Short.MAX_VALUE)
                        .addComponent(lbl_plaintext)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(Plaintext, javax.swing.GroupLayout.PREFERRED_SIZE, 83, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(lbl_key)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(Key)))
                .addGap(10, 10, 10)
                .addComponent(lbl_ciphertext)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addGap(27, 27, 27)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(Encrypt_Btn, javax.swing.GroupLayout.PREFERRED_SIZE, 32, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(Exit_Btn, javax.swing.GroupLayout.PREFERRED_SIZE, 32, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(Decrypt_Btn, javax.swing.GroupLayout.PREFERRED_SIZE, 32, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(Reset_Btn, javax.swing.GroupLayout.PREFERRED_SIZE, 32, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGap(34, 34, 34))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(18, 18, 18)
                        .addComponent(Ciphertext, javax.swing.GroupLayout.PREFERRED_SIZE, 93, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(17, 17, 17))))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void PlaintextActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_PlaintextActionPerformed
        //Người dùng nhập, không thao tác!
    }//GEN-LAST:event_PlaintextActionPerformed

    private void KeyActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_KeyActionPerformed
        //Người dùng nhập, không thao tác!
    }//GEN-LAST:event_KeyActionPerformed

    private void CiphertextActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_CiphertextActionPerformed
        //Người dùng nhập, không thao tác!
    }//GEN-LAST:event_CiphertextActionPerformed
    // XỬ LÝ NÚT MÃ HÓA
    private void Encrypt_BtnActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_Encrypt_BtnActionPerformed
        // --- KIỂM TRA ĐIỀU KIỆN TRƯỚC KHI MÃ HÓA ---
        if (Plaintext.getText().trim().isEmpty()) {// Nếu ô Plaintext rỗng, thông báo lỗi và dừng
            JOptionPane.showMessageDialog(this, "Không thể mã hóa — vui lòng nhập Plaintext!", "Cảnh báo", JOptionPane.WARNING_MESSAGE);
            return;// Dừng hàm
        }

        if (Key.getText().trim().isEmpty()) { // Nếu không nhập Key
            JOptionPane.showMessageDialog(this, "Vui lòng nhập Key để mã hóa!", "Cảnh báo", JOptionPane.WARNING_MESSAGE);
            return;
        }

        if (!Ciphertext.getText().trim().isEmpty()) {// Nếu Ciphertext có sẵn dữ liệu
            JOptionPane.showMessageDialog(this, "Không thể mã hóa — ô Ciphertext chỉ dùng để hiển thị kết quả!", "Cảnh báo", JOptionPane.WARNING_MESSAGE);
            return;
        }

        // --- PLAYFAIR ENCRYPTION ---
        // --- CHUẨN BỊ DỮ LIỆU ---
        // Chuyển tất cả sang chữ hoa, loại bỏ ký tự không phải A–Z, và thay J bằng I (để thống nhất, coi như bỏ J)
        String text = Plaintext.getText().toUpperCase().replaceAll("[^A-Z]", "").replace("J", "I");
        String key = Key.getText().toUpperCase().replaceAll("[^A-Z]", "").replace("J", "I");

        // Bước 1: Tạo bảng khóa 5x5
        String matrixKey = "";
        for (int i = 0; i < key.length(); i++) {
        // Duyệt từng ký tự trong key, nếu chưa có trong matrixKey thì thêm vào
            if (matrixKey.indexOf(key.charAt(i)) == -1) {
                matrixKey += key.charAt(i);
            }
        }
        for (char c = 'A'; c <= 'Z'; c++) {
            if (c == 'J') {// Playfair bỏ chữ J
                continue;
            }
            if (matrixKey.indexOf(c) == -1) {
                matrixKey += c;// Thêm các ký tự còn thiếu để đủ 25 chữ
            }
        }
        // Chuyển chuỗi matrixKey thành ma trận 5x5
        char[][] matrix = new char[5][5];
        int k = 0;
        for (int i = 0; i < 5; i++) {
            for (int j = 0; j < 5; j++) {
                matrix[i][j] = matrixKey.charAt(k++);
            }
        }

        // Bước 2: Xử lý plaintext thành cặp
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < text.length(); i++) {
            sb.append(text.charAt(i));
            if (i + 1 < text.length()) {// Nếu hai ký tự liên tiếp giống nhau thì chèn 'Z' giữa
                if (text.charAt(i) == text.charAt(i + 1)) {
                    sb.append('Z');
                } else {// Nếu khác nhau thì lấy cặp kế tiếp
                    sb.append(text.charAt(++i));
                }
            }
        }
        // Nếu độ dài lẻ, thêm 'Z' vào cuối để đủ cặp
        if (sb.length() % 2 != 0) {
            sb.append('Z');
        }
        String preparedText = sb.toString();

        // Bước 3: Mã hóa từng cặp
        StringBuilder cipher = new StringBuilder();
        for (int i = 0; i < preparedText.length(); i += 2) {
            char a = preparedText.charAt(i);
            char b = preparedText.charAt(i + 1);
            int rowA = 0, colA = 0, rowB = 0, colB = 0;
            // Tìm vị trí (hàng, cột) của từng ký tự trong bảng (bằng thì gán)
            for (int r = 0; r < 5; r++) {
                for (int c = 0; c < 5; c++) {
                    if (matrix[r][c] == a) {
                        rowA = r;
                        colA = c;
                    }
                    if (matrix[r][c] == b) {
                        rowB = r;
                        colB = c;
                    }
                }
            }
            // --- QUY TẮC MÃ HÓA ---
            if (rowA == rowB) { // Cùng hàng => thay mỗi ký tự bằng ký tự bên phải
                cipher.append(matrix[rowA][(colA + 1) % 5]);
                cipher.append(matrix[rowB][(colB + 1) % 5]);
            } else if (colA == colB) { // Cùng cột => thay bằng ký tự phía dưới
                cipher.append(matrix[(rowA + 1) % 5][colA]);
                cipher.append(matrix[(rowB + 1) % 5][colB]);
            } else { // Khác hàng & cột => tạo hình chữ nhật
                cipher.append(matrix[rowA][colB]);
                cipher.append(matrix[rowB][colA]);
            }
        }
        // Hiển thị kết quả mã hóa
        Ciphertext.setText(cipher.toString());
    }//GEN-LAST:event_Encrypt_BtnActionPerformed
    // XỬ LÝ GIẢI MÃ
    private void Decrypt_BtnActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_Decrypt_BtnActionPerformed
        // --- KIỂM TRA ĐIỀU KIỆN TRƯỚC KHI GIẢI MÃ ---
        if (Ciphertext.getText().trim().isEmpty()) {
            JOptionPane.showMessageDialog(this, "Không thể giải mã — vui lòng nhập Ciphertext!", "Cảnh báo", JOptionPane.WARNING_MESSAGE);
            return;
        }

        if (Key.getText().trim().isEmpty()) {
            JOptionPane.showMessageDialog(this, "Vui lòng nhập Key để giải mã!", "Cảnh báo", JOptionPane.WARNING_MESSAGE);
            return;
        }

        if (!Plaintext.getText().trim().isEmpty()) {
            JOptionPane.showMessageDialog(this, "Không thể giải mã — ô Plaintext chỉ dùng để hiển thị kết quả!", "Cảnh báo", JOptionPane.WARNING_MESSAGE);
            return;
        }
        // --- PLAYFAIR DECRYPTION ---
        String cipher = Ciphertext.getText().toUpperCase().replaceAll("[^A-Z]", "").replace("J", "I");
        String key = Key.getText().toUpperCase().replaceAll("[^A-Z]", "").replace("J", "I");

        // Bước 1: Tạo lại bảng khóa 5x5 (y chang nút mã hóa)
        String matrixKey = "";
        for (int i = 0; i < key.length(); i++) {
            if (matrixKey.indexOf(key.charAt(i)) == -1) {
                matrixKey += key.charAt(i);
            }
        }
        for (char c = 'A'; c <= 'Z'; c++) {
            if (c == 'J') {
                continue;
            }
            if (matrixKey.indexOf(c) == -1) {
                matrixKey += c;
            }
        }
        char[][] matrix = new char[5][5];
        int k = 0;
        for (int i = 0; i < 5; i++) {
            for (int j = 0; j < 5; j++) {
                matrix[i][j] = matrixKey.charAt(k++);
            }
        }

        // Bước 2: Giải mã từng cặp (cũng y chang mã hóa)
        StringBuilder plain = new StringBuilder();
        for (int i = 0; i < cipher.length(); i += 2) {
            char a = cipher.charAt(i);
            char b = cipher.charAt(i + 1);
            int rowA = 0, colA = 0, rowB = 0, colB = 0;
            // Tìm vị trí (hàng, cột) của từng ký tự trong bảng (bằng thì gán)
            for (int r = 0; r < 5; r++) {
                for (int c = 0; c < 5; c++) {
                    if (matrix[r][c] == a) {
                        rowA = r;
                        colA = c;
                    }
                    if (matrix[r][c] == b) {
                        rowB = r;
                        colB = c;
                    }
                }
            }

            if (rowA == rowB) { /// Cùng hàng => dịch trái
                plain.append(matrix[rowA][(colA + 4) % 5]);
                plain.append(matrix[rowB][(colB + 4) % 5]);
            } else if (colA == colB) { // Cùng cột => dịch lên
                plain.append(matrix[(rowA + 4) % 5][colA]);
                plain.append(matrix[(rowB + 4) % 5][colB]);
            } else { // Khác hàng cột => tạo hình chữ nhật
                plain.append(matrix[rowA][colB]);
                plain.append(matrix[rowB][colA]);
            }
        }
        // Hiển thị kết quả giải mã
        Plaintext.setText(plain.toString());
    }//GEN-LAST:event_Decrypt_BtnActionPerformed

    private void Exit_BtnActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_Exit_BtnActionPerformed
        System.exit(0); // Thoát chương trình
    }//GEN-LAST:event_Exit_BtnActionPerformed
    // XỬ LÝ NÚT RESET – XÓA DỮ LIỆU NHẬP
    private void Reset_BtnActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_Reset_BtnActionPerformed
        Plaintext.setText("");    // Xóa ô nhập Plaintext
        Key.setText("");          // Xóa ô nhập Key
        Ciphertext.setText("");   // Xóa ô Ciphertext
    }//GEN-LAST:event_Reset_BtnActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ReflectiveOperationException | javax.swing.UnsupportedLookAndFeelException ex) {
            logger.log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(() -> new MCD_PlayFair().setVisible(true));
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JTextField Ciphertext;
    private javax.swing.JButton Decrypt_Btn;
    private javax.swing.JButton Encrypt_Btn;
    private javax.swing.JButton Exit_Btn;
    private javax.swing.JTextField Key;
    private javax.swing.JTextField Plaintext;
    private javax.swing.JButton Reset_Btn;
    private javax.swing.JLabel Tittle;
    private javax.swing.JButton jButton3;
    private javax.swing.JButton jButton4;
    private javax.swing.JLabel lbl_ciphertext;
    private javax.swing.JLabel lbl_key;
    private javax.swing.JLabel lbl_plaintext;
    // End of variables declaration//GEN-END:variables
}
